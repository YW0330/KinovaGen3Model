//
// Academic License - for use in teaching, academic research, and meeting
// course requirements at degree granting institutions only.  Not for
// government, commercial, or other organizational use.
// File: kinova_J_and_Jinv.cpp
//
// MATLAB Coder version            : 4.3
// C/C++ source code generated on  : 18-Aug-2022 17:03:06
//

// Include Files
#include "kinova_J_and_Jinv.h"
#include "kinova_J_and_Jinv_data.h"
#include "kinova_J_and_Jinv_initialize.h"
#include "rt_nonfinite.h"
#include "svd.h"
#include <math.h>
#include <string.h>

// Function Definitions

//
// KINOVA_J
//     J = KINOVA_J(D2,D3,D4,D5,D6,D7,D8,D9,D10,D11,D12,Q1,Q2,Q3,Q4,Q5,Q6)
// Arguments    : double q1
//                double q2
//                double q3
//                double q4
//                double q5
//                double q6
//                double J[42]
//                double Jinv[42]
// Return Type  : void
//
void kinova_J_and_Jinv(double q1, double q2, double q3, double q4, double q5,
  double q6, double J[42], double Jinv[42])
{
  double t2;
  double t3;
  double t4;
  double t5;
  double t6;
  double t7;
  double t8;
  double t9;
  double t10;
  double t11;
  double t12;
  double t13;
  double t16;
  double t18;
  double t19;
  double t20;
  double t21;
  double t22;
  double t24;
  double t27_tmp;
  double t30_tmp;
  double t34_tmp;
  double t35_tmp;
  double t39;
  double t43;
  double t44;
  double t25;
  double t29;
  double t37;
  double t41;
  double t46;
  double t48;
  double t62;
  double t63;
  double t68;
  double t66;
  double t81;
  double t90;
  double t107_tmp;
  double t107;
  double t82;
  double t85;
  double t89;
  double t118;
  double t94_tmp;
  double t94;
  double t105_tmp;
  double t124;
  double t115_tmp;
  double t119;
  double t120;
  double t128;
  double t130;
  double t129;
  double t134;
  double t135;
  double J_tmp;
  double b_J_tmp;
  double c_J_tmp;
  double d_J_tmp;
  double e_J_tmp;
  double f_J_tmp;
  double A[42];
  boolean_T p;
  int br;
  double X[42];
  double U[42];
  double s[6];
  double V[36];
  int i;
  int vcol;
  int j;
  int r;
  int ar;
  int ib;
  int ia;
  int i1;
  int ic;
  if (isInitialized_kinova_J_and_Jinv == false) {
    kinova_J_and_Jinv_initialize();
  }

  //     This function was generated by the Symbolic Math Toolbox version 8.4.
  //     18-Aug-2022 16:52:15
  t2 = cos(q1);
  t3 = cos(q2);
  t4 = cos(q3);
  t5 = cos(q4);
  t6 = cos(q5);
  t7 = cos(q6);
  t8 = sin(q1);
  t9 = sin(q2);
  t10 = sin(q3);
  t11 = sin(q4);
  t12 = sin(q5);
  t13 = sin(q6);
  t16 = 0.0064 * t2;
  t18 = 0.0064 * t8;
  t19 = t2 * t4;
  t20 = t3 * t5;
  t21 = t2 * t10;
  t22 = t4 * t8;
  t24 = t8 * t10;
  t27_tmp = 0.2104 * t2 * t9;
  t30_tmp = 0.2104 * t8 * t9;
  t34_tmp = t8 * t9;
  t35_tmp = t9 * t10;
  t39 = t2 * t5 * t9;
  t43 = t5 * t8 * t9;
  t44 = t4 * t9 * t11;
  t25 = 0.0064 * t19;
  t29 = 0.0064 * t22;
  t37 = t3 * t21;
  t41 = t3 * t24;
  t4 = t3 * t11 + t4 * t5 * t9;
  t46 = 0.0064 * t37;
  t48 = 0.0064 * t41;
  t62 = t21 + t3 * t22;
  t63 = t22 + t37;
  t68 = t20 + -t44;
  t66 = t19 + -t41;
  t21 = t24 + -(t3 * t19);
  t41 = t11 * t62;
  t81 = t7 * t68;
  t90 = t6 * t9 * t10 + t12 * t4;
  t107_tmp = t35_tmp * t12 - t6 * t4;
  t107 = 0.1059 * t13 * t107_tmp;
  t82 = t11 * t21;
  t85 = 0.1059 * t81;
  t89 = t43 + t41;
  t118 = 0.1815 * (t81 + t13 * t107_tmp);
  t94_tmp = t2 * t9;
  t94 = t94_tmp * t11 + t5 * t21;
  t22 = t7 * t89;
  t105_tmp = t39 - t82;
  t37 = -t7 * t105_tmp;
  t124 = ((0.1059 * t68 + t85) + t107) + t118;
  t115_tmp = t34_tmp * t11 - t5 * t62;
  t21 = t13 * (t12 * t66 + -t6 * t115_tmp);
  t4 = 0.0064 * t9 * t10;
  t62 = ((0.2084 * t20 + t4) + -(0.2084 * t44)) + t124;
  t119 = t22 + t21;
  t24 = (0.2104 * t3 + t4) + t62;
  t4 = t13 * (t12 * t63 + t6 * t94);
  t19 = 0.2104 * t3 + t24;
  t5 = 0.1059 * t4;
  t120 = t37 + t4;
  t128 = (0.1059 * t22 + 0.1059 * t21) + 0.1815 * t119;
  t22 = 0.1815 * t120;
  t130 = 0.1059 * t89 + t128;
  t129 = (0.1059 * t37 + t5) + t22;
  t4 = ((0.2084 * t43 + 0.2084 * t41) + 0.0064 * t66) + t130;
  t134 = ((t25 + t30_tmp) + -t48) + t4;
  t21 = ((-(0.2084 * t39) + 0.0064 * t63) + 0.2084 * t82) + (-0.1059 * t105_tmp
    + t129);
  t135 = ((t29 + t46) + -t27_tmp) + t21;
  J_tmp = (((((-t16 - t25) - t30_tmp) - t30_tmp) + t48) - t4) - 0.0054 * t2;
  J[0] = J_tmp;
  b_J_tmp = (t18 + -t27_tmp) + t135;
  J[1] = b_J_tmp + 0.0054 * t8;
  J[2] = 0.0;
  J[3] = 0.0;
  J[4] = 0.0;
  J[5] = -1.0;
  c_J_tmp = t2 * t19;
  J[6] = c_J_tmp;
  d_J_tmp = -t8 * t19;
  J[7] = d_J_tmp;
  J[8] = -t8 * ((t16 + t30_tmp) + t134) + t2 * b_J_tmp;
  J[9] = t8;
  J[10] = t2;
  J[11] = 0.0;
  b_J_tmp = -t3 * t134 + t34_tmp * t24;
  J[12] = b_J_tmp;
  e_J_tmp = ((-t27_tmp + t29) + t46) + t21;
  f_J_tmp = t3 * e_J_tmp + t94_tmp * t24;
  J[13] = f_J_tmp;
  e_J_tmp = t94_tmp * t134 + t34_tmp * e_J_tmp;
  J[14] = e_J_tmp;
  t46 = -t2 * t9;
  J[15] = t46;
  J[16] = t34_tmp;
  J[17] = -t3;
  t29 = t66 * t62 - t35_tmp * t4;
  J[18] = t29;
  t25 = -t63 * t62 + t35_tmp * t21;
  J[19] = t25;
  t48 = -t63 * t4 + t66 * t21;
  J[20] = t48;
  J[21] = t63;
  J[22] = t66;
  t43 = -t9 * t10;
  J[23] = t43;
  t94_tmp = -t68 * t130 + t89 * t124;
  J[24] = t94_tmp;
  t11 = ((t5 + t22) - 0.1059 * t105_tmp) - 0.1059 * t7 * t105_tmp;
  t5 = t68 * t11 + t124 * t105_tmp;
  J[25] = t5;
  t11 = t89 * t11 + t130 * t105_tmp;
  J[26] = t11;
  t62 = -t39 + t82;
  J[27] = t62;
  J[28] = t89;
  t24 = -t20 + t44;
  J[29] = t24;
  t19 = (t85 + t107) + t118;
  t37 = t6 * t66 + t12 * t115_tmp;
  t41 = -t90 * t128 + t37 * t19;
  J[30] = t41;
  t22 = t6 * t63 - t12 * t94;
  t19 = t90 * t129 - t22 * t19;
  J[31] = t19;
  t21 = t129 * t37 - t128 * t22;
  J[32] = t21;
  J[33] = t22;
  J[34] = t37;
  J[35] = -t90;
  J[36] = 0.0;
  J[37] = 0.0;
  J[38] = 0.0;
  J[39] = t120;
  J[40] = t119;
  t4 = -t81 + -t13 * t107_tmp;
  J[41] = t4;
  A[0] = J_tmp;
  A[7] = ((t18 + -t27_tmp) + t135) + 0.0054 * t8;
  A[14] = 0.0;
  A[21] = 0.0;
  A[28] = 0.0;
  A[35] = -1.0;
  A[1] = c_J_tmp;
  A[8] = d_J_tmp;
  A[15] = -t8 * ((t16 + t30_tmp) + t134) + t2 * ((t18 + -t27_tmp) + t135);
  A[22] = t8;
  A[29] = t2;
  A[36] = 0.0;
  A[2] = b_J_tmp;
  A[9] = f_J_tmp;
  A[16] = e_J_tmp;
  A[23] = t46;
  A[30] = t34_tmp;
  A[37] = -t3;
  A[3] = t29;
  A[10] = t25;
  A[17] = t48;
  A[24] = t63;
  A[31] = t66;
  A[38] = t43;
  A[4] = t94_tmp;
  A[11] = t5;
  A[18] = t11;
  A[25] = t62;
  A[32] = t89;
  A[39] = t24;
  A[5] = t41;
  A[12] = t19;
  A[19] = t21;
  A[26] = t22;
  A[33] = t37;
  A[40] = -t90;
  A[6] = 0.0;
  A[13] = 0.0;
  A[20] = 0.0;
  A[27] = t120;
  A[34] = t119;
  A[41] = t4;
  p = true;
  for (br = 0; br < 42; br++) {
    X[br] = 0.0;
    if ((!p) || rtIsNaN(A[br])) {
      p = false;
    }
  }

  if (!p) {
    for (i = 0; i < 42; i++) {
      X[i] = rtNaN;
    }
  } else {
    svd(A, U, s, V);
    t4 = fabs(s[0]);
    if ((!rtIsInf(t4)) && (!rtIsNaN(t4))) {
      if (t4 <= 2.2250738585072014E-308) {
        t4 = 4.94065645841247E-324;
      } else {
        frexp(t4, &vcol);
        t4 = ldexp(1.0, vcol - 53);
      }
    } else {
      t4 = rtNaN;
    }

    t4 *= 7.0;
    r = -1;
    br = 0;
    while ((br < 6) && (s[br] > t4)) {
      r++;
      br++;
    }

    if (r + 1 > 0) {
      vcol = 1;
      for (j = 0; j <= r; j++) {
        t4 = 1.0 / s[j];
        i = vcol + 5;
        for (br = vcol; br <= i; br++) {
          V[br - 1] *= t4;
        }

        vcol += 6;
      }

      for (vcol = 0; vcol <= 36; vcol += 6) {
        i = vcol + 1;
        j = vcol + 6;
        if (i <= j) {
          memset(&X[i + -1], 0, ((j - i) + 1) * sizeof(double));
        }
      }

      br = 0;
      for (vcol = 0; vcol <= 36; vcol += 6) {
        ar = -1;
        br++;
        i = br + 7 * r;
        for (ib = br; ib <= i; ib += 7) {
          ia = ar;
          j = vcol + 1;
          i1 = vcol + 6;
          for (ic = j; ic <= i1; ic++) {
            ia++;
            X[ic - 1] += U[ib - 1] * V[ia];
          }

          ar += 6;
        }
      }
    }
  }

  for (i = 0; i < 6; i++) {
    for (j = 0; j < 7; j++) {
      Jinv[j + 7 * i] = X[i + 6 * j];
    }
  }
}

//
// File trailer for kinova_J_and_Jinv.cpp
//
// [EOF]
//
